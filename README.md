# CodeVSReborn

[CODE VS Reborn](<https://codevs.jp>) で作成したプログラムです>

予選結果：42位

開発環境：Visual Studio 2017
使用言語：C++17

## 実行方法

### GCC

gcc-7以上でコンパイルしてください。
コンパイルオプションは以下の通りです。
実行時のオプションはありません。

``` sh
g++ -std=c++17 -O3 -finput-charset=cp932 -fexec-charset=cp932 -m64 -march=native main.cpp
```

詳細はuploadフォルダ内の[run.sh](<https://github.com/ao1415/CodeVSReborn/blob/master/upload/run.sh>)を参照してください。

### Visual Studio 2017

Visual Studio 2017 Update 3以上を適応した状態でビルドしてください。

## ファイル構成

AI関係

- main.cpp  
メイン関数とデバッグ用の関数があります。入出力等を行います。
- Ai.hpp  
探査用のクラスです。メイン関数からThink関数が呼ばれます。
- Evaluation.hpp  
フィールドの評価用クラスです。Aiクラスからコンストラクタのみ呼ばれます。
- Field.hpp  
フィールドの管理と、シミュレーションを行うクラスです。
- Pack.hpp  
パック用のクラスです。

設定関係

- Base.hpp  
ライブラリや型、共有で使用する構造体などを宣言しています。
- Config.hpp  
探査のパラメータを設定しています。
- Constant.hpp  
プログラム内で使用する定数を宣言しています。

ユーティリティ関係

- Share.hpp  
全体で共有したい情報を管理するクラスです。
- SIMD.hpp  
SIMD命令をインクルードします。
- Pool.hpp  
メモリプールのクラスです。
- Clock.hpp  
時間測定用のクラスです。
- FixedGrid.hpp  
2次元配列用のクラスです。

## 方針

各ターンに、12手先までをChokudaiSearchで探索する。
各ターンの1手目は全探索を行い、発火するか連鎖を組むか選択する。
発火判定では、発火した場合としなかった場合で相手の状態を3ターン先まで全探査し、
相手の最大スコアが下がれば発火するようにした。

フィールドに何連鎖存在しているかの判別には、各列に1～9のブロックを落として判別した。
また、評価関数では主に存在している連鎖数とそれを発火できるターン数を使用した。

## 高速化

Visual Studioのパフォーマンスプロファイルラーで解析したところ、
全体の計算時間に対してキューの挿入に10%・評価時に80%の時間がかかっていたのでその2点の高速化を行った。

### キューの挿入

探査用の構造体(500Byte程)をそのまま挿入すると時間がかかったのでポインタに変更した。
C++では確保した領域を自分で解放する必要があるため、メモリプールを作成し一元管理を行った。

メモリプールは以下の仕様で実装した。

- ターン毎にデータが紛失する
- 確保した領域の先頭から順番に使用する
- 最後に使用した領域のみ使わなかったことにできる
- 確保した領域を使い切った場合はnullポインタを返す

最終的に800MB程の領域がメモリプールで持っていかれた。

### 評価時

1～9のブロックを各列に落とすため、シミュレーションに大部分の時間がかかっていた。
そのため、bit演算で消滅・落下処理ができるように以下のように変更した。

フィールドを19bit(型の関係上32bitで処理する)の1列が10個集まったものと考える。
フィールドは各数字(1～9・11のブロック)ごとのテーブルと、空白用(0のブロック)のテーブルで構成される。

消滅判定は各テーブル列のANDを計算することで判定した。

``` cpp:判定の一例
//右の消滅判定(1と9のブロックに対して)
right     |= (table[1][x]     ) & table[9][x + 1];
rightUP   |= (table[1][x] << 1) & table[9][x + 1];
rightDown |= (table[1][x] >> 1) & table[9][x + 1];
```

落下処理は、各数字のビットマップとブロック有無のビットマップの各列に対してpext命令を行った。
pext命令用のマスクは、消滅ブロックとブロック有無のビットマップから作成した。

## 感想

高速化で頭がいっぱいになって、戦略の部分が考えられてなかった。
また、上位陣のリプレイから戦略や工夫点の解析ができていなかった。

解析するべき内容や、実行環境の工夫ができていなかった。

bit演算とCPU命令について調べることができたのはよかった。

## Q.なんでC++17なの？

A.[[nodiscard]]属性を使いたかった。
